# my-list-use

时间复杂度：

```
时间复杂度描述算法执行所需时间相对于输入规模的增长趋势。通过分析算法中基本操作的执行次数，确定其时间复杂度
常见时间复杂度类型：
    常数阶O(1):算法的执行时间不随输入规模变化 
    对数阶O(log n):算法的执行时间随着输入规模的对数增长
    线性阶O(n):算法的执行时间与输入规模成正比
    线性对数阶O(n log n):常见于高效排序算法，如归并排序和快速排序
    平方阶O(n^2):算法的执行时间与输入规模的平方成正比，常见于简单排序算法，如冒泡排序
    指数阶O(2^n):算法的执行时间随着输入规模的指数增长，常见于解决组合问题的递归算法
```

空间复杂度：

```
空间复杂度描述算法在运行过程中所需的额外内存空间相对于输入规模的增长趋势。它衡量算法的内存使用效率
常见空间复杂度类型：
    O(1):算法仅使用常数大小的额外空间
    O(n):算法使用与输入规模成正比的额外空间
    O(n^2):算法使用与输入规模成平方成正比的额外空间

```

##### Comparator接口的sort方法

    - ComparatorTest.java 直接调用了了Comparator的sort方法实现数组的排序
        底层原理是使用binarySort方法，其原理是使用二分插入的方式实现了数据的排序

##### 插入排序

    - InsertionSort.java    
	 * 	插入排序就是將需要排序的對象與前面的對象進行一個一個的比較，如果比前面的小則繼續向前比較，直到比到最前面的位置或者比到比自己小的
     * 位置，此過程即比較大小又替換位置

##### ArrayList最大长度

    - MaxSize.java
    * ArrayList源码中的数组最大长度为 Integer.MAX_VALUE - 8
    * 但是在创建对象初始化的时候不会允许创建这么大的数组，这与数组及内存等都有关系，
    * ArrayList底层是数组，数组的最大值是Integer.MAX_VALUE

##### 归并排序

    - MergeSort.java
    * 归并排序是一种分值的排序算法，它将数组分成两个子数组，两个子数组排序之后，再将排序后的子数组进行合并
    * 最终得到排序后的结果

##### 快速排序

    - QuickSort.java
    * 选择最后一个元素为基准元素，依次将数组的第一个元素与基准元素进行比较，如果这个元素比基准元素大则继续遍历，如果比基准元素小则将这个元素
    * 与第一个比基准元素大的位置进行替换，并且记录下第几次进行替换，然后再继续遍历，如果这个元素比基准元素大则继续遍历，如果比基准元素小则
    * 继续执行替换的步奏，替换的位置为上次替换的位置加1，按照上面的步奏，直至遍历到最后的基准元素，然后将基准元素替换到上面记录的被替换的
    * 元素的后一个位置；
    * 以记录下基准元素替换的位置为分解线，左侧的位置继续执行以非上一次的基准元素的元素进行比较，右侧的部分则以最后一个元素为基准元素继续执行
    * 上面的步奏，继续遍历直至最后完成排序

##### CopyOnWriteArrayList

    - CopyOnWriteArrayListTest.java
     通过CopyOnWriteArrayList实现了对线程安全的list进行增删改查，此List的实现是通过新复制一个数组出来修改复制后的数组，进行相关的操作之后
     再将数组替换，适用于多查询，少修改的场景

##### Vector

    - VectorTest.java
      Vector是Java很早就提供的线程安全的数组，其方法上都使用了Syncronized关键字来保证线程的安全

##### SynchronizedList

    - SynchronizedListTest.java
      通过Collections.SynchronizedList()将线程不安全的数组变成线程安全的数组，其返回的对象是Collections的内部类
      SynchronizedList或者SynchronizedRandomList，这两个类都是使用static进行修饰并且对于的类上都使用了Synchronized关键字进行修饰
      实现了线程的安全
